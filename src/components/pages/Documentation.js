import React from "react";
import Slider from "../inc/Slider";
import Log from "../inc/Log";

const lightyellow = "#f9dcc4"
const lightorange = "#fec89a"

const overallContent = "In this three-day hackathon, our objective was to design and build a versatile rover. The rover was to be wirelessly controlled through a dedicated website, which included a comprehensive control center. This control center enabled real-time navigation, live camera feed viewing, and sensor data monitoring. Additionally, the rover was equipped with a grabbing mechanism capable of picking up small objects from various heights, showcasing its practical application potential."
const initialPlan = "Our initial plan involved designing a four-wheel rover equipped with two ultrasonic sensors (front and back), a front-facing camera, and temperature and humidity sensors mounted on top. The chassis design featured two straight levels connected by eight columns, though we reduced this to four columns for a stable yet easily accessible structure for circuitry checks. We considered mounting the camera and front ultrasonic sensor on a servo motor for enhanced navigation flexibility. However, we ultimately decided against it to avoid unnecessary complexity, as it did not significantly improve navigation within the field of play."
const mechChasContent = `To approach the overall mechanical design of the rover, we first took inspiration from previous NASA rovers and basic arduino rovers found on the internet. Our main concerns were size, ability to carry all the components, and weight. In order to create a basic chassis design, collaboration with the electrical engineer was necessary. Not only was it important to map out where the electrical components would be stationed, it was also crucial to allow proper spacing for all possible wires as well as including gaps in the chassis for wires to feed from the bottom to the top of the rover. From there, I was able to CAD an initial design of both the bottom and top chassis that would be manufactured by laser cutting acrylic. Additional holes were eventually added to the chassis design to station parts of the arm assembly.Throughout the design process, components were refined many times until proper fitment of them was achieved. One part in particular was the acrylic support of the wheel motor. Because our design of the rover attempted to house the wheel motors under the bottom chassis, a solution to secure the motor was required. After a discussion with the team, we decided on a mushroom shaped piece that would hold itself above the chassis while extending below. This would provide space for fasteners and align with prebuilt holes on the motor. Each iteration of the motor wheel support consisted of a new failure. Initially, the piece was not long enough as the thickness of the bottom chassis wasn’t fully considered, leaving the holes greatly misaligned. Then, the top part was not wide enough and risked breaking due to the weight of the motor and wheel. The third iteration was stable and the holes were aligned perfectly. When inserting the fasteners, I discovered that I did not take into account that the head of the screw was much wider than the hole, meaning the screw closest to the chassis would not fit. After fixing this issue, the part was finally perfected and I was able to move onto the next part. I will not forget the many trips I made from the upstairs makerspace to the downstairs to reprint the motor support.`
const mechArmClawContent = `After finishing most of the basic structures of the rover, I was challenged to design a mechanical arm that would be able to pick up a 2x2x2 object at an arbitrary height. Initially, I wanted to have an arm with two joints, however, the team decided it was too complicated and would weigh too much with the addition of an extra arm and servo motor. As a result, we decided on an arm that would use a stepper motor and a claw that would use a servo motor. The claw would rely on a single gear rotated by a servo motor, which would simultaneously rotate two other gears. These two gears would extend and attach to a scoop which was large enough to enclose any 2x2x2 object. The scoop was basically a box cut diagonally in half. Through CAD, I was able to create mini assemblies to test the fitment and movements of the arm and claw. Ultimately, based on printing and physical testing, attaching the scoop proved to be too heavy for the stepper motor to lift, therefore we decided to get rid of it and just rely on the small arms attached to the gears. Due to time limitations, any possible addition of a second stepper motor was not realistic. After much trial and error, we arrived at a rover design that would fulfill the requirements. Our rover can showcase a mechanical design tailored for required exploration and data collection. The rover features a protective top housing structure, ensuring shielding against environmental elements. Its four wheels, equipped with the motors, provide stability and mobility across most terrains. The mechanical arm at the up-front part of the rover, complete with gears and a claw-shape handle, is designed for grabbing objects and handing them to another position. Integrated sensors, including a camera for visual navigation, an ultrasonic sensor for obstacle detection, and a temperature and humidity sensor for environmental monitoring, are placed to optimize functionality and able to be used for showing the real-time sensor data on our own website. The rover’s chassis supports these components.`
const websiteContent = "We designed our website using React and Bootstrap. React's component-based architecture enables scalable development and reduces the length of our code, while Bootstrap enhances the website's appearance. The website comprised three main pages: Home, Documentation, and Control Center. The Home page introduced the team members, their majors, and their specific contributions to the rover. The Documentation page was used to track our project progress, and the Control Center provided an interface to interact with and control the rover. Two challenges we faced during the website design were positioning elements nicely on the page and implementing keyboard interactions. React's modular code structure helped us address these challenges effectively, ensuring a clean layout and responsive control functionality."
const circuitContent = "The brain was the Pi Pico, a microprocessor that takes in USB for the power source. The criteria were that the project needs to be driven through Pico, use claws and an arm to grab two by two by two inches at least 5 ounces, a camera was used to display the rover field of view for the user to drive, and have distance, temperature, and humidity readings. Four-wheel drive was chosen as our primary source of project control. Two H-bridges were used to control four DC motors and two nine-volt batteries in parallel were used to power motors. Enablers pins were initially used but, due to time constraints, were later scrapped to ensure constraints performed out of the drivetrain. There were multiple times when the motor was not getting enough power; a multimeter was used to check if it was delivered across the 5V terminal and the power terminal concerning the ground to check if 9V was delivered correctly. The 12V jumper was not removed because the power source was less than 12V. Two ultrasonic sensors(HC-SR04) were used to read the distance between the front and back of the rover. One DHT11 sensor was used to sensor both temperature and humidity. The power source was 5V, and two other pins per ultrasonic sensor were used to collect data from the pico. One small problem with the DHT11 sensor: if broken, the program would crash. The DHT11 sensor is sensitive to power, so 3.3V was only provided with a GPIO pin. The arm and claw consisted of one stepper and one servo motor. The stepper motor was used to lift the arm because the stepper provided more power than the servo. The stepper required four GPIO pins and either 5V or 12V. The project did not provide a precisely 12V battery; therefore, the 5V option was used for the stepper. The claw portion used a servo using 5V to power it instead of 9V because the drive train motor requires more power to function. The ESP32-CAM was used for the camera module of the rover. The ESP32-CAM used a separate system compared to the Pico and required the usage of Arduino IDE. The camera was not connected to the Pico; when powered and programmed, it provided a website link to view it. Two power banks were used to power Pico and ESP32-CAM, but this was not the best idea. Instead of using a power bank, the lithium battery and hardware would have been better to maintain stable power sources. The scrapped idea, due to time constraints, used a 5V voltage regulator with a lithium battery to power Pico. It had a physical power button using a push button and MOSFET, a servo, and an LED ring to allow the camera to rotate and allow the driver to see in the dark."
const picoProgContent = "The Pico uses Python as the primary language, whereas the ESP32 uses C++. The Pico was required to connect wifi so it needed to be able to subscribe to MQTT servers and publish data from the sensor reading. Many libraries were used to aid with the programming, such as the DHT library for the temperature and humidity sensor, the HCSR04 library for the ultrasonic sensor, connections for the MQTT and internet, and the stepper library for the stepper. All the pins used from the hardware were coded to ensure Pico could communicate with devices. Custom functions were used for the drive train. A call-back function was used when the website from the MQTT server was published, and if-else statements were used to handle published messages. There were handle arms, handle directions, and sensor measurements, which were called from the call-back function. In the main function, the Wi-Fi connection was first set with an MQTT server connection, then subscribed to topics needed to control the rover. A try-catch block was used to check the MQTT server by using polling. The polling was required because there is published bandwidth, and 1 second was used to ensure the program does not crash. The library function and main python file were flashed on to the Pico and checked with Thonny to ensure there were no extra files. The ESP32-CAM uses Arduino IDE with C++ and a custom library called ESP32, which uses an AI thinker board with an example library from the ESP32-CAM library. WiFi settings were hardcoded and uploaded to the ESP32-CAM. The ESP32-CAM was able to connect to WiFi and display properly on the website "
const mqttContent = "To enable seamless communication between our rover and website, we utilized the HiveMQ MQTT broker. This setup facilitated a bi-directional connection between two nodes: the rover and the website. The rover node published real-time sensor data, including temperature, humidity, and ultrasonic readings. This data was transmitted to the website, where it could be monitored and analyzed. On the other hand, the website node published user commands for controlling the rover's movements and operating the grabbing arm. These commands were received by the rover, enabling precise and responsive control based on user inputs. One challenge we encountered was a significant delay in processing user control requests by the Pico. The Pico became overwhelmed with the volume of commands, especially when a key, such as the 'w' key for moving forward, was held down, sending continuous requests every second. We resolved this issue by modifying the control mechanism to send a single move forward request when a key was pressed and held, followed by a stop command when the key was released. This adjustment allowed for much smoother communication and more responsive control of the rover. By employing the HiveMQ MQTT broker and refining our control strategy, we achieved reliable and efficient communication, ensuring both the sensor data from the rover and the control commands from the website were transmitted smoothly and accurately."
const finalTestingContent = "During final testing, the rover initially struggled to drive because its battery voltage was low. This was solved by simply replacing the 9V batteries. Next, the working claw gear was accidentally super-glued together and could no longer move. The use of much human force was to no avail, and a random hairdryer found in the corner of the makerspace was not enough to melt the superglue in time. Surprisingly, the car could be driven remotely through the website, and the ultrasonic, temperature, and humidity sensors were functional. We also realized the camera was flipped horizontally and vertically on the website after final assembly, but we fixed that using the camera interface by turning the V-flip and H mirror on. The ultrasonic front and back labeling, as well as the turn left and turn right keys were flipped on our website. However, the fix was easy and quick as it was a simple flip of the variables on the website. In the end, we successfully tested our rover for about 15 minutes, navigating through the tunnel multiple times and completing various other challenges."
const competitionContent = "Unfortunately, due to many unforeseen problems, the rover struggled to maintain proper battery control when the final test began. The first two minutes were spent debugging the wiring and checking if everything was correctly powered. Eventually, it was solved until halfway through the course. After emerging from the tunnel, a small bump was hit when backing up to test the rear end ultrasonic sensor, and the rover undoubtedly had some loose wiring. Because of this, more debugging was needed during the competition by rechecking the wiring for an additional three minutes to solve it. With just over 45 seconds remaining, the rover spontaneously began moving again, and we were luckily able to complete a few more challenges to earn more points. Due to half the time used to debug wiring, we could not complete the arm challenge. Thankfully, we managed to complete the majority of challenges."



{/* Documentation page with progress images and paragraphs explaining our hack journey*/}
function Documentation(){
    return (
            <section className="section">
                <div className="container">
                    <div className="row">
                        <div className="col-md-12 text-center">
                            <h3 className="main-heading">Documentation</h3>
                            <div className="underline mx-auto"></div>
                        </div>
                           
                    </div>
                </div>
                {/* Slider of Progress photos.*/}
                <Slider/>

                {/* Each log component is a paragraph with a title and content with alternating background color*/}
                <Log color={lightyellow} title = "Overall" content={overallContent}></Log>
                <Log color={lightorange} title = "Initial Plan" content={initialPlan}></Log>
                <Log color={lightyellow} title = "Mechanical Chassis Design" content={mechChasContent}></Log>
                <Log color={lightyellow} title = "Mechanical Arm and Claw Design:" content={mechArmClawContent}></Log>
                <Log color={lightorange} title = "Website Design" content={websiteContent}></Log>
                <Log color={lightyellow} title = "Circuit Design" content={circuitContent}></Log>
                <Log color={lightorange} title = "Pico Programming" content={picoProgContent}></Log>
                <Log color={lightyellow} title = "MQTT Connections" content={mqttContent}></Log>
                <Log color={lightorange} title = "Final Testing" content={finalTestingContent}></Log>
                <Log color={lightyellow} title = "Competition Performance" content={competitionContent}></Log>
            </section>
        
    );
}


export default Documentation;